{
  "language": "Solidity",
  "sources": {
    "contracts/HypercertMetadata.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.14;\n\nimport \"./interfaces/IHypercertMetadata.sol\";\nimport \"./utils/ArraysUpgradeable.sol\";\nimport \"./utils/StringsExtensions.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/Base64Upgradeable.sol\";\n\ninterface IHypercertMinter {\n    struct Claim {\n        bytes32 claimHash;\n        uint64[2] workTimeframe;\n        uint64[2] impactTimeframe;\n        bytes32[] workScopes;\n        bytes32[] impactScopes;\n        bytes32[] rights;\n        address[] contributors;\n        uint256 totalUnits;\n        uint16 version;\n        bool exists;\n        string name;\n        string description;\n        string uri;\n    }\n\n    function workScopes(bytes32 workScopeId) external view returns (string memory);\n\n    function impactScopes(bytes32 impactScopeId) external view returns (string memory);\n\n    function rights(bytes32 rightsId) external view returns (string memory);\n\n    function getImpactCert(uint256 claimID) external view returns (Claim memory);\n\n    function balanceOf(uint256 tokenId) external view returns (uint256);\n}\n\ninterface IHypercertSVG {\n    function generateSvgHypercert(\n        string memory name,\n        string memory description,\n        uint64[2] memory workTimeframe,\n        uint64[2] memory impactTimeframe,\n        uint256 totalUnits\n    ) external view returns (string memory);\n\n    function generateSvgFraction(\n        string memory name,\n        string memory description,\n        uint64[2] memory workTimeframe,\n        uint64[2] memory impactTimeframe,\n        uint256 units,\n        uint256 totalUnits\n    ) external view returns (string memory);\n}\n\n/// @dev Hypercertificate metadata creation logic\ncontract HypercertMetadata is IHypercertMetadata {\n    using ArraysUpgradeable for uint64[2];\n    using ArraysUpgradeable for uint256[];\n    using ArraysUpgradeable for string[];\n    using StringsExtensions for bool;\n    using StringsUpgradeable for uint256;\n\n    address svgGenerator;\n\n    constructor(address svgGenerationAddress) {\n        svgGenerator = svgGenerationAddress;\n    }\n\n    function generateTokenURI(uint256 slotId, uint256 tokenId) external view virtual returns (string memory) {\n        IHypercertMinter.Claim memory claim = IHypercertMinter(msg.sender).getImpactCert(slotId);\n        uint256 units = IHypercertMinter(msg.sender).balanceOf(tokenId);\n\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64Upgradeable.encode(\n                        abi.encodePacked(\n                            '{\"name\":\"',\n                            claim.name,\n                            '\",\"description\":\"',\n                            claim.description,\n                            '\",\"image\":\"',\n                            _generateImageStringFraction(claim, units),\n                            '\",\"external_url\":\"',\n                            claim.uri,\n                            '\",\"properties\":{',\n                            abi.encodePacked(\n                                '\"balance\":',\n                                _propertyString(\"balance\", \"Units held by fraction.\", units, false),\n                                \",\"\n                            ),\n                            abi.encodePacked('\"scopesOfWork\":', _mapWorkScopesIdsToValues(claim.workScopes), \",\"),\n                            abi.encodePacked('\"scopesOfImpact\":', _mapImpactScopesIdsToValues(claim.impactScopes), \",\"),\n                            abi.encodePacked('\"rights\":', _mapRightsIdsToValues(claim.rights)),\n                            \"}}\"\n                        )\n                    )\n                )\n            );\n    }\n\n    function generateSlotURI(uint256 slotId) external view virtual returns (string memory) {\n        IHypercertMinter.Claim memory claim = IHypercertMinter(msg.sender).getImpactCert(slotId);\n        return\n            string(\n                abi.encodePacked(\n                    \"data:application/json;base64,\",\n                    Base64Upgradeable.encode(\n                        abi.encodePacked(\n                            '{\"name\":\"',\n                            claim.name,\n                            '\",\"description\":\"',\n                            claim.description,\n                            '\",\"image\":\"',\n                            _generateImageStringHypercert(claim),\n                            '\",\"properties\":{',\n                            string.concat('\"name\":', _propertyString(\"name\", \"Name of hypercert.\", claim.name, false)),\n                            \"}\"\n                        )\n                    )\n                )\n            );\n    }\n\n    function _slotProperties(IHypercertMinter.Claim memory claim) internal view virtual returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    _propertyString(\n                        \"work_timeframe\",\n                        \"The period during which the work relating to the claim was done.\",\n                        claim.workTimeframe,\n                        true\n                    ),\n                    \",\",\n                    _mapWorkScopesIdsToValues(claim.workScopes),\n                    \",\",\n                    _propertyString(\n                        \"impact_timeframe\",\n                        \"The period during which the impact relating to the claim was made.\",\n                        claim.impactTimeframe,\n                        true\n                    ),\n                    \",\",\n                    _mapImpactScopesIdsToValues(claim.impactScopes),\n                    \",\",\n                    _mapRightsIdsToValues(claim.rights),\n                    \",\",\n                    _propertyString(\n                        \"total_units\",\n                        \"Total units issued across all tokens with this slot.\",\n                        claim.totalUnits,\n                        false\n                    ),\n                    \",\",\n                    _propertyString(\"external_link\", \"URI of additional data related to the claim.\", claim.uri, false)\n                )\n            );\n    }\n\n    function _tokenProperties(IHypercertMinter.Claim memory claim, uint256 units)\n        internal\n        view\n        virtual\n        returns (string memory)\n    {\n        return\n            string(\n                abi.encodePacked(\n                    _propertyString(\"units\", \"Units issued to this token.\", units, false),\n                    \",\",\n                    _propertyString(\"fraction\", \"Fraction issued to this token.\", units / claim.totalUnits, false)\n                )\n            );\n    }\n\n    function _generateImageStringFraction(IHypercertMinter.Claim memory claim, uint256 units)\n        internal\n        view\n        returns (string memory)\n    {\n        return\n            string.concat(\n                \"data:image/svg+xml;base64,\",\n                Base64Upgradeable.encode(\n                    bytes(\n                        IHypercertSVG(svgGenerator).generateSvgFraction(\n                            claim.name,\n                            claim.description,\n                            claim.workTimeframe,\n                            claim.impactTimeframe,\n                            units,\n                            claim.totalUnits\n                        )\n                    )\n                )\n            );\n    }\n\n    function _generateImageStringHypercert(IHypercertMinter.Claim memory claim) internal view returns (string memory) {\n        return\n            string.concat(\n                \"data:image/svg+xml;base64,\",\n                Base64Upgradeable.encode(\n                    bytes(\n                        IHypercertSVG(svgGenerator).generateSvgHypercert(\n                            claim.name,\n                            claim.description,\n                            claim.workTimeframe,\n                            claim.impactTimeframe,\n                            claim.totalUnits\n                        )\n                    )\n                )\n            );\n    }\n\n    function _propertyString(\n        string memory name_,\n        string memory description_,\n        string memory value_,\n        bool isIntrinsic_\n    ) internal pure virtual returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    '{\"name\":\"',\n                    name_,\n                    '\",\"description\":\"',\n                    description_,\n                    '\",\"value\":\"',\n                    value_,\n                    '\",\"is_intrinsic\":\"',\n                    isIntrinsic_.toString(),\n                    '\"}'\n                )\n            );\n    }\n\n    function _propertyString(\n        string memory name_,\n        string memory description_,\n        uint256 value_,\n        bool isIntrinsic_\n    ) internal pure virtual returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    '{\"name\":\"',\n                    name_,\n                    '\",\"description\":\"',\n                    description_,\n                    '\",\"value\":',\n                    value_.toString(),\n                    ',\"is_intrinsic\":\"',\n                    isIntrinsic_.toString(),\n                    '\"}'\n                )\n            );\n    }\n\n    function _propertyString(\n        string memory name_,\n        string memory description_,\n        bytes32[] memory value_,\n        bool isIntrinsic_\n    ) internal pure virtual returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    '{\"name\":\"',\n                    name_,\n                    '\",\"description\":\"',\n                    description_,\n                    '\",\"value\":',\n                    value_,\n                    ',\"is_intrinsic\":\"',\n                    isIntrinsic_.toString(),\n                    '\"}'\n                )\n            );\n    }\n\n    function _propertyString(\n        string memory name_,\n        string memory description_,\n        uint256[] memory array_,\n        bool isIntrinsic_\n    ) internal pure virtual returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    '{\"name\":\"',\n                    name_,\n                    '\",\"description\":\"',\n                    description_,\n                    '\",\"value\":\"',\n                    array_.toCsv(),\n                    '\",\"is_intrinsic\":\"',\n                    isIntrinsic_.toString(),\n                    '\"}'\n                )\n            );\n    }\n\n    function _propertyString(\n        string memory name_,\n        string memory description_,\n        uint64[2] memory array_,\n        bool isIntrinsic_\n    ) internal pure virtual returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    '{\"name\":\"',\n                    name_,\n                    '\",\"description\":\"',\n                    description_,\n                    '\",\"value\":\"',\n                    array_.toString(),\n                    '\",\"is_intrinsic\":\"',\n                    isIntrinsic_.toString(),\n                    '\"}'\n                )\n            );\n    }\n\n    function _propertyString(\n        string memory name_,\n        string memory description_,\n        string[] memory array_,\n        bool isIntrinsic_\n    ) internal pure virtual returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    '{\"name\":\"',\n                    name_,\n                    '\",\"description\":\"',\n                    description_,\n                    '\",\"value\":\"',\n                    array_.toCsv(),\n                    '\",\"is_intrinsic\":\"',\n                    isIntrinsic_.toString(),\n                    '\"}'\n                )\n            );\n    }\n\n    /// @dev use keys to look up values in the supplied mapping\n    function _mapWorkScopesIdsToValues(bytes32[] memory keys) internal view returns (string memory) {\n        uint256 len = keys.length;\n        string[] memory values = new string[](len);\n        for (uint256 i = 0; i < len; i++) {\n            values[i] = IHypercertMinter(msg.sender).workScopes(keys[i]);\n        }\n        return\n            string(\n                abi.encodePacked(\n                    '{\"name\":\"Scopes of Work\",\"description\":\"Scopes of work encapsulated in this hypercert fraction.\",\"value\":[',\n                    values.toCsv(),\n                    '],\"is_intrinsic\":\"true\"}'\n                )\n            );\n    }\n\n    /// @dev use keys to look up values in the supplied mapping\n    function _mapImpactScopesIdsToValues(bytes32[] memory keys) internal view returns (string memory) {\n        uint256 len = keys.length;\n        string[] memory vals;\n        if (len > 0) {\n            string[] memory values = new string[](len);\n            for (uint256 i = 0; i < len; i++) {\n                values[i] = IHypercertMinter(msg.sender).impactScopes(keys[i]);\n            }\n            vals = values;\n        }\n\n        return\n            string(\n                abi.encodePacked(\n                    '{\"name\":\"Scopes of Impact\",\"description\":\"Scopes of impact encapsulated in this hypercert fraction.\",\"value\":[',\n                    vals.toCsv(),\n                    '],\"is_intrinsic\":\"true\"}'\n                )\n            );\n    }\n\n    /// @dev use keys to look up values in the supplied mapping\n    function _mapRightsIdsToValues(bytes32[] memory keys) internal view returns (string memory) {\n        uint256 len = keys.length;\n        string[] memory values = new string[](len);\n        for (uint256 i = 0; i < len; i++) {\n            values[i] = IHypercertMinter(msg.sender).rights(keys[i]);\n        }\n        return\n            string(\n                abi.encodePacked(\n                    '{\"name\":\"Rights\",\"description\":\"Rights associated with owning the hypercert (fractions)\",\"value\":[',\n                    values.toCsv(),\n                    '],\"is_intrinsic\":\"true\"}'\n                )\n            );\n    }\n}\n"
    },
    "contracts/interfaces/IHypercertMetadata.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\n/**\n * @title Hypercert metadata generator interface\n */\ninterface IHypercertMetadata {\n    function generateSlotURI(uint256 slotId) external view returns (string memory);\n\n    function generateTokenURI(uint256 slotId, uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/utils/ArraysUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary ArraysUpgradeable {\n    using StringsUpgradeable for uint256;\n\n    /**\n     * @dev calculate the sum of the elements of an array\n     */\n    function getSum(uint8[] memory array) internal pure returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 sum = 0;\n        for (uint256 i = 0; i < array.length; i++) sum += array[i];\n        return sum;\n    }\n\n    function toString(uint64[2] memory array) internal pure returns (string memory) {\n        return string(abi.encodePacked(\"[\", uint256(array[0]).toString(), \",\", uint256(array[1]).toString(), \"]\"));\n    }\n\n    function toCsv(uint256[] memory array) internal pure returns (string memory) {\n        uint256 len = array.length;\n        string memory result;\n        for (uint256 i = 1; i < len; i++) {\n            string memory s = array[i].toString();\n            if (bytes(result).length == 0) result = s;\n            else result = string(abi.encodePacked(result, \",\", s));\n        }\n\n        return result;\n    }\n\n    function toCsv(string[] memory array) internal pure returns (string memory) {\n        uint256 len = array.length;\n        string memory result;\n        for (uint256 i = 1; i < len; i++) {\n            string memory s = string(abi.encodePacked('\"', array[i], '\"'));\n            if (bytes(result).length == 0) result = s;\n            else result = string(abi.encodePacked(result, \",\", s));\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/utils/StringsExtensions.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary StringsExtensions {\n    /**\n     * @dev returns either \"true\" or \"false\"\n     */\n    function toString(bool value) internal pure returns (string memory) {\n        if (value) return \"true\";\n        return \"false\";\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/Base64Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64Upgradeable {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}